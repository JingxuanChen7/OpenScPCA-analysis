---
title: "Clustering results"
author: "Jingxuan Chen"
date: "`r Sys.Date()`"
output: 
  html_document:
    code_folding: hide
    toc: true
    toc_depth: 4
params:
  library_id: SCPCL000851
  level: compartment
  anchor_assay: RNA
---

## Introduction

In this notebook, we'll explore clustering results.

Before rendering this notebook, make sure to:

-   Run standard Seurat workflow using `scripts/00_preprocessing_rds.R`.
-   Run anchor transfer using `scripts/01_anchor_transfer_seurat.R`.
-   Run Self-assembling manifolds (SAM) with `scripts/02_clustering.R` for an alternative feature selection strategy.

## Setup

```{r setup, include=FALSE}
knitr::opts_chunk$set(warning = FALSE, message = FALSE) 

```

### Packages

```{r packages}
suppressPackageStartupMessages({
  library(dplyr)
  library(Seurat)
  library(ggplot2)
  library(SCpubr)
  library(scCustomize)
})
```

### Paths

#### Base directories

```{r base paths}
# The base path for the OpenScPCA repository, found by its (hidden) .git directory
path_repo <- rprojroot::find_root(rprojroot::is_git_root)

# The path to this module
path_anal <- file.path(path_repo,"analyses","cell-type-wilms-tumor-14") 
```

#### Input and output files

```{r paths}
library_id <- params$library_id
level <- params$level
anchor_assay <- params$anchor_assay

# Preprocessing obj path
pre_dir <- file.path(path_anal, "scratch", "00_preprocessing_rds")
pre_obj <- SeuratObject::LoadSeuratRds( file.path(pre_dir, paste0(library_id,".rdsSeurat")) )

# Anchor transfer path (LogNormalize ver.)
anchor_dir <- file.path(path_anal, "results", "01_anchor_transfer_seurat", anchor_assay)
predictions <- read.csv( file.path(anchor_dir, paste0(library_id, "_", level, ".csv")) )

# SAM path
sam_dir <- file.path(path_anal, "scratch", "02_clustering")
sam_obj <- readRDS( file.path(sam_dir, paste0("sam_",library_id,".rds")) )
```

```{r functions}
suppressPackageStartupMessages({
  source(file = file.path(path_repo,"packages","rOpenScPCA","R","calculate-clusters.R"))
  # source(file = file.path(path_anal,"scripts","utils","01_anchor_transfer_seurat_functions.R"))
})
```

## Analysis content

### Standard Seurat workflow

This workflow uses `SCTransform` normalization, Seurat feature selection, default Louvain clustering, and UMAP dimensional reduction.

```{r}
pre_obj <- AddMetaData(object = pre_obj, metadata = predictions)
sample_obj <- pre_obj
# setup features for plotting
features <- sample_obj@meta.data[ grepl("prediction.score", colnames(sample_obj@meta.data)) ]
features <- features[,colSums(features) > 0]
# setup color palette
# clusters <- levels(unlist(pre_obj[[plot_cluster]]))
# color <- Polychrome::glasbey.colors( length( clusters ) )
# names(color) <- clusters
pred_ids <- unique(predictions$predicted.id)
color <- Polychrome::glasbey.colors( length( pred_ids ) +1  )
color <- color[-1]
names(color) <- pred_ids
color['Unknown'] <- "gray90"
# figure size
featureplot_width <- 10
featureplot_height <- (length(features) %/% 3 + 1) * 3
vlnplot_width <- 12
vlnplot_height <- length(features) * 1.3
```

```{r }
Seurat::DimPlot(sample_obj, reduction = "umap", group.by = "predicted.id", 
                        label = F, cols = color, alpha = 0.1) +
    ggtitle(paste0(library_id))
```

Prediction score distribution generated by anchor transfer.

```{r, fig.width=featureplot_width, fig.height=featureplot_height }
FeaturePlot(sample_obj, features = colnames(features), 
            keep.scale = "all", ncol = 3) &
  NoLegend() & 
  FontSize(main = 10)

```

Prediction score distribution for each prediction category.

```{r, fig.width=vlnplot_width, fig.height=vlnplot_height}
scCustomize::Stacked_VlnPlot(pre_obj, features = colnames(features), 
                            split.by = "predicted.id", group.by = "predicted.id",
                            plot_legend = F, x_lab_rotate = T, 
                            y.max = 1,
                            colors_use = color) +
  theme(axis.text.x = element_text(angle = 45, hjust = 1)) 
```

#### Default Louvain clustering

UMAP colored by clustering.

```{r }
plot_cluster <- "seurat_clusters"
Seurat::DimPlot(sample_obj, reduction = "umap", group.by = plot_cluster, label = T)
```

Proportion of cell types per cluster.

```{r fig.width=7, fig.height=3}
SCpubr::do_BarPlot(sample_obj, 
                   group.by = "predicted.id",
                   split.by = plot_cluster,
                   position = "fill", legend.title = paste0("Predicted ", level),
                   legend.position = "right",
                   plot.title = "Proportion of cells types per cluster",
                   colors.use = color,
                   flip = FALSE)
```

Number of cells for each cluster.

```{r fig.width=7, fig.height=3}
SCpubr::do_BarPlot(sample = sample_obj, 
                   split.by = plot_cluster, 
                   group.by = "predicted.id",
                   legend.position = "right", legend.title = paste0("Predicted ", level),
                   plot.title = "Number of cells types per cluster",
                   position = "stack",
                   colors.use = color) 
```

Prediction score distribution for each cluster.

```{r, fig.width=vlnplot_width, fig.height=vlnplot_height}
scCustomize::Stacked_VlnPlot(sample_obj, features = colnames(features), 
                            split.by = plot_cluster, group.by = plot_cluster,
                            plot_legend = F, x_lab_rotate = T, 
                            y.max = 1,
                            colors_use = color) +
  theme(axis.text.x = element_text(angle = 45, hjust = 1)) 
```

#### Perform Leiden algorithm with custom function for clustering.

```{r}
cluster_df <- calculate_clusters(sample_obj, 
                                 algorithm = "leiden", 
                                 resolution = 1, objective_function = "modularity",
                                 seed = 233)
sample_obj <- AddMetaData(object = sample_obj, metadata = cluster_df)
```

UMAP colored by clustering.

```{r fig.width=5, fig.height=5}
plot_cluster <- "cluster"
Seurat::DimPlot(sample_obj, reduction = "umap", group.by = plot_cluster, label = T)
```

Proportion of cell types per cluster.

```{r fig.width=7, fig.height=3}
SCpubr::do_BarPlot(sample_obj, 
                   group.by = "predicted.id",
                   split.by = plot_cluster,
                   position = "fill", legend.title = paste0("Predicted ", level),
                   legend.position = "right",
                   plot.title = "Proportion of cells types per cluster",
                   colors.use = color,
                   flip = FALSE)
```

Number of cells for each cluster.

```{r fig.width=7, fig.height=3}
SCpubr::do_BarPlot(sample = sample_obj, 
                   split.by = plot_cluster, 
                   group.by = "predicted.id",
                   legend.position = "right", legend.title = paste0("Predicted ", level),
                   plot.title = "Number of cells types per cluster",
                   position = "stack",
                   colors.use = color) 
```

Prediction score distribution for each cluster.

```{r, fig.width=vlnplot_width, fig.height=vlnplot_height}
scCustomize::Stacked_VlnPlot(sample_obj, features = colnames(features), 
                            split.by = plot_cluster, group.by = plot_cluster,
                            plot_legend = F, x_lab_rotate = T, 
                            y.max = 1,
                            colors_use = color) +
  theme(axis.text.x = element_text(angle = 45, hjust = 1)) 
```

### SAM workflow

Run [SAM](https://elifesciences.org/articles/48994) algorithm as an alternative feature selection method.

```{r}
sam_obj <- AddMetaData(object = sam_obj, metadata = predictions)
sample_obj <- sam_obj
# setup features for plotting
features <- sample_obj@meta.data[ grepl("prediction.score", colnames(sample_obj@meta.data)) ]
features <- features[,colSums(features) > 0]
# setup color palette
# clusters <- levels(unlist(sam_obj[[plot_cluster]]))
# color <- Polychrome::glasbey.colors( length( clusters ) )
# names(color) <- clusters
color <- Polychrome::glasbey.colors( length( pred_ids ) +1  )
color <- color[-1]
names(color) <- pred_ids
color['Unknown'] <- "gray90"
```

```{r }
Seurat::DimPlot(sample_obj, reduction = "umap", group.by = "predicted.id", 
                        label = F, cols = color, alpha = 0.1) +
    ggtitle(paste0(library_id))
```

Prediction score distribution generated by anchor transfer.

```{r fig.width=featureplot_width, fig.height=featureplot_height}
FeaturePlot(sample_obj, features = colnames(features), 
            keep.scale = "all", ncol = 3) &
  NoLegend() & 
  FontSize(main = 10)
```

#### Default clutering with SAM (`leiden`)

UMAP colored by clustering.

```{r }
plot_cluster <- "leiden_clusters"
Seurat::DimPlot(sample_obj, reduction = "umap", group.by = plot_cluster, label = T)
```

Proportion of cell types per cluster.

```{r fig.width=7, fig.height=3}
SCpubr::do_BarPlot(sample_obj, 
                   group.by = "predicted.id",
                   split.by = plot_cluster,
                   position = "fill", legend.title = paste0("Predicted ", level),
                   legend.position = "right",
                   plot.title = "Proportion of cells types per cluster",
                   colors.use = color,
                   flip = FALSE)
```

Number of cells for each cluster.

```{r fig.width=7, fig.height=3}
SCpubr::do_BarPlot(sample = sample_obj, 
                   split.by = plot_cluster, 
                   group.by = "predicted.id",
                   legend.position = "right", legend.title = paste0("Predicted ", level),
                   plot.title = "Number of cells types per cluster",
                   position = "stack",
                   colors.use = color) 
```

Prediction score distribution for each cluster.

```{r, fig.width=vlnplot_width, fig.height=vlnplot_height}
scCustomize::Stacked_VlnPlot(sample_obj, features = colnames(features), 
                            split.by = plot_cluster, group.by = plot_cluster,
                            plot_legend = F, x_lab_rotate = T, 
                            y.max = 1,
                            colors_use = color) +
  theme(axis.text.x = element_text(angle = 45, hjust = 1)) 
```

#### Perform Leiden algorithm with custom function for clustering.

```{r}
cluster_df <- calculate_clusters(sample_obj, 
                                 algorithm = "leiden", 
                                 resolution = 1, objective_function = "modularity",
                                 seed = 233)
sample_obj <- AddMetaData(object = sample_obj, metadata = cluster_df)
```

UMAP colored by clustering.

```{r }
plot_cluster <- "cluster"
Seurat::DimPlot(sample_obj, reduction = "umap", group.by = plot_cluster, label = T)
```

Proportion of cell types per cluster.

```{r fig.width=7, fig.height=3}
SCpubr::do_BarPlot(sample_obj, 
                   group.by = "predicted.id",
                   split.by = plot_cluster,
                   position = "fill", legend.title = paste0("Predicted ", level),
                   legend.position = "right",
                   plot.title = "Proportion of cells types per cluster",
                   colors.use = color,
                   flip = FALSE)
```

Number of cells for each cluster.

```{r fig.width=7, fig.height=3}
SCpubr::do_BarPlot(sample = sample_obj, 
                   split.by = plot_cluster, 
                   group.by = "predicted.id",
                   legend.position = "right", legend.title = paste0("Predicted ", level),
                   plot.title = "Number of cells types per cluster",
                   position = "stack",
                   colors.use = color) 
```

Prediction score distribution for each cluster.

```{r, fig.width=vlnplot_width, fig.height=vlnplot_height}
scCustomize::Stacked_VlnPlot(sample_obj, features = colnames(features), 
                            split.by = plot_cluster, group.by = plot_cluster,
                            plot_legend = F, x_lab_rotate = T, 
                            y.max = 1,
                            colors_use = color) +
  theme(axis.text.x = element_text(angle = 45, hjust = 1)) 
```

## Session Info

```{r session info}
# record the versions of the packages used in this analysis and other environment information
sessionInfo()
```
